#summary Introduction to using the GTM HTTP Fetcher classes.
#labels Featured

<wiki:toc max_depth="3" />

= Introduction =

The Google Toolbox for Mac HTTP Fetcher is a set of classes to simplify http operations in Cocoa applications.

== When would you use the fetcher? ==

  * When you just want a result from one or more requests without writing much networking code
  * When you want the "standard" behavior for connections, such as redirection handling
  * When you want automatic retry on failures
  * When you want to avoid cookie collisions with Safari and other applications
  * When you may be requesting the same resource repeatedly, and want to minimize network traffic
  * When you want a convenient log of http requests and responses
  * When you need to set a credential for the http operation

= Using the Fetcher =

== Adding the Fetcher to Your Project ==

Check out the "top-of-trunk" fetcher sources with a Mac terminal window and the command on the [http://code.google.com/p/gtm-http-fetcher/source/checkout source checkout page].

Only the `GTMHTTPFetcher.h/m` source files are required. The Logging class file is optional but useful for all applications. If your application will make a series of related fetches, the Service and History classes will likely be useful.

|| *Source files* || *Purpose* ||
|| GTMHTTPFetcher.h/m || required ||
|| GTMHTTPFetcherLogging.h/m || http logging (often helpful) ||
|| GTMHTTPFetcherService.h/m, GTMHTTPFetchHistory.h/m || history across fetches ||
|| GTMMIMEDocument.h/m, GTMGatherInputStream.h/m || multipart MIME uploads ||
|| GTMHTTPUploadFetcher.h/m || [http://code.google.com/apis/gdata/docs/resumable_upload.html resumable-uploads] ||


== Usage ==

=== Fetching a Request ===

Because the fetcher is implemented as a wrapper on NSURLConnection, it is asynchronous.

The fetcher can be used most simply by adding GTMHTTPFetcher.h/m to your project, and fetching a URL like this:

{{{
  #import "GTMHTTPFetcher.h"
  
  NSURL *url = [NSURL URLWithString:@"http://www.example.com/"];
  NSURLRequest *request = [NSURLRequest requestWithURL:url];
  GTMHTTPFetcher* myFetcher = [GTMHTTPFetcher fetcherWithRequest:request];
  [myFetcher beginFetchWithDelegate:self
                  didFinishSelector:@selector(myFetcher:finishedWithData:error:)];
}}}

Each fetcher object is good for "one shot"; do not reuse an instance for a second fetch.

The fetcher may be created auto-released (as shown above with `+fetcherWithRequest:`) so it will release itself after the fetch completion callback has been invoked.  The fetcher retains itself implicitly as long as a connection is pending.

But if you may need to cancel the fetcher prior to completion, allocate the fetcher with `initWithRequest:` and have the delegate release the fetcher in the callback.

Upload data may be optionally specified with the fetcher's `postData` and `postStream` properties.

The callback looks like
{{{
- (void)myFetcher:(GTMHTTPFetcher *)fetcher finishedWithData:(NSData *)retrievedData error:(NSError *)error {
  if (error != nil) {
    // failed; either an NSURLConnection error occurred, or the server returned
    // a status value of at least 300
    //
    // the NSError domain string for server status errors is kGTMHTTPFetcherStatusDomain
    int status = [error code];
  } else {
    // fetch succeeded
  }
}
}}}

Typically, your callbacks will have a selector named to indicate what was fetched, like
{{{
imageFetcher:finishedWithData:error:

settingsFetcher:finishedWithData:error:
}}}

The delegate is retained by the fetcher until the fetch has completed or has been canceled.

=== Blocks-style Callback ===

The callback may also be supplied as an Objective-C block:
{{{
  [myFetcher beginFetchWithCompletionHandler:^(NSData *retrievedData, NSError *error) {
    if (error != nil) {
      // status code or network error
    } else {
      // succeeded
    }
  }];
}}}

Other fetcher delegate methods also have block versions.

=== Cookies ===

There are three supported mechanisms for remembering cookies between fetches.

By default, GTMHTTPFetcher uses a mutable array held statically to track cookies for all instantiated fetchers. This keeps cookies set by the server during the fetch from interfering with Safari cookie settings, and vice versa.  The fetcher cookies are forgotten when the application quits.

To rely instead on WebKit's global NSHTTPCookieStorage, call setCookieStorageMethod: with kGTMHTTPFetcherCookieStorageMethodSystemDefault.

If the fetcher is created from a GTMHTTPFetcherService object
then the fetcher is set to use the cookie storage in the
service object rather than the application static storage. Each fetcher service object instance has its own "cookie jar".

=== Monitoring Received Data ===

An optional received data selector can be set as the `receivedDataSelector` property. The selector should have the signature

{{{
- (void)myFetcher:(GTMHTTPFetcher *)fetcher receivedData:(NSData *)dataReceivedSoFar;
}}}

The number of bytes received so far during the fetch is available as `[dataReceivedSoFar length]`. This number may go down if a redirect causes the download to begin again from a new server.

If supplied by the server, the anticipated total download size is available as`[[myFetcher response] expectedContentLength]` (though it may be -1 for unknown download sizes.)

=== Proxies ===

Proxy handling is invisible so long as the system has a valid credential in
the keychain, which is normally true (else most NSURL-based apps would encounter proxy errors.)

But when there is a proxy authetication error, the the fetcher
will invoke the callback method with the NSURLChallenge in the error's
userInfo. The error method can get the challenge info like this:
{{{
 NSURLAuthenticationChallenge *challenge = [[error userInfo] objectForKey:kGTMHTTPFetcherErrorChallengeKey];
 BOOL isProxyChallenge = [[challenge protectionSpace] isProxy];
}}}
If a proxy error occurs, you can ask the user for the proxy username/password
and call the next fetcher's setProxyCredential: to provide the credentials for the
next attempt to fetch.

=== Automatic Retry ===

The fetcher can optionally create a timer and reattempt certain kinds of
fetch failures (status codes 408, request timeout; 503, service unavailable;
504, gateway timeout; networking error NSURLErrorTimedOut.)  The user may set a retry selector to
customize the errors which will be retried.

Retries are done in an exponential-backoff fashion (that is, after 1 second,
2, 4, 8, and so on, with a bit of randomness added to the initial interval.)

Enabling automatic retries looks like this:
{{{
 myFetcher.retryEnabled = YES;
}}}
With retries enabled, the success or failure callbacks are called only
when no more retries will be attempted. Calling the fetcher's stopFetching
method will terminate the retry timer, without the finished or failure
selectors being invoked.

Optionally, the client may set the maximum retry interval:
{{{
 myFetcher.maxRetryInterval = 60.0; // in seconds; default is 60 seconds
                                    // for downloads, 600 for uploads
}}}
Also optionally, the client may provide a callback selector to determine
if a status code or other error should be retried.
{{{
 myFetcher.retrySelector = @selector(myFetcher:willRetry:forError:);
}}}

If set, the retry selector should have the signature:
{{{
  -(BOOL)fetcher:(GTMHTTPFetcher *)fetcher willRetry:(BOOL)suggestedWillRetry forError:(NSError *)error
}}}
and return YES to set the retry timer or NO to fail without additional
fetch attempts.

The retry method may return the `suggestedWillRetry` argument to get the
default retry behavior.  Server status codes are present in the
error argument, and have the domain kGTMHTTPFetcherStatusDomain. The
user's method may look something like this:
{{{
-(BOOL)myFetcher:(GTMHTTPFetcher *)fetcher willRetry:(BOOL)suggestedWillRetry forError:(NSError *)error {

    // perhaps examine [error domain] and [error code], or [fetcher retryCount]
    //
    // return YES to start the retry timer, NO to proceed to the failure
    // callback, or suggestedWillRetry to get default behavior for the
    // current error domain and code values.
    return suggestedWillRetry;
}
}}}

=== Avoiding Duplicate Responses ===

The fetcher can track ETag headers from responses for each requested URL and
provide an "If-None-Match" header. This allows the server to save
bandwidth by providing a status message instead of repeated response
data.

To get this behavior, create the fetcher from an GTMHTTPFetcherService object,
and in the fetch callback look for an error with code 304
(kGTMHTTPFetcherStatusNotModified) like this:
{{{
- (void)myFetcher:(GTMHTTPFetcher *)fetcher finishedWithData:(NSData *)data error:(NSError *)error {
   if ([error code] == kGTMHTTPFetcherStatusNotModified) {
     // data is empty; use the data from the previous finishedWithData: for this URL
   } else {
     // handle other server status code
   }
}
}}}

The fetcher service object can optionally cache the ETagged responses in memory as well, so later fetchers will return the response data from the cache instead of the 304 status.
{{{
myFetcherService.shouldCacheETaggedData = YES;
}}}

The default cache size is 1 MB on iOS, 15 MB on Mac OS X. It can be set in the fetch history object:
{{{
myFetcherService.fetchHistory. = YES;
}}}

=== Uploading Multipart MIME Documents ===

The library includes a class for generating multipart MIME documents. See the header `GTMMIMEDocument.h` for instructions on generating an NSInputStream with the MIME data. The fetcher's `postStream` property may be used to specify the generated input stream to upload.

== Fetcher Service Objects ==

Fetchers that do not need shared history may be generated independently, as shown above in "Fetching a Request".

Alternatively, the fetcher service class provides a "memory" across a sequence of fetcher objects generated by the service.

A sequence of fetchers can be generated by a common instance of GTMHTTPFetcherService, like
{{{
GTMHTTPFetcherService *myFetcherService = [[GTMHTTPFetcherService alloc] init];
GTMHTTPFetcher* myFirstFetcher = [myFetcherService fetcherWithRequest:request1];
GTMHTTPFetcher* mySecondFetcher = [myFetcherService fetcherWithRequest:request2];
}}}

The fetcher service tracks cookies, allowing a sequence of fetchers to share a cookie jar, separate from the WebKit cookie storage.

For fetch responses with ETag headers, the fetcher service remembers the response headers. Future fetcher requests to the same URL will be given an "If-None-Match" header, telling the server to return a 304 Not Modified status if the response is unchanged, reducing the server load and network traffic.

Optionally, the fetcher service can cache the data that was returned in the responses that contained ETag headers. If a later fetch results in a 304 status, indicating the requested resource has not changed, the fetcher will return the cached data to the client along with a 200 status, hiding the 304.

== HTTP Logging ==

All traffic using GTMHTTPFetcher can be easily logged.  Call
{{{
  [GTMHTTPFetcher setLoggingEnabled:YES];
}}}
to begin generating log files.

Log files are put into a folder on the desktop called `GTMHTTPDebugLogs`
unless another directory is specified with `+setLoggingDirectory`.

In the iOS simulator, the default logs location is the user's home
directory in ~/Library/Application Support.  On the device, the
default logs location is the application's documents directory on the device.

*Tip*: Use the Finder's "Sort By Date" to find the most recent logs.

Each run of an application gets a separate set of log files.  An html
file is generated to simplify browsing the run's http transactions.
The html file includes Javascript links for inline viewing of uploaded
and downloaded data, and links to plain-text versions of each request/response
useful for copying and pasting into bug reports.

A symlink is created in the logs folder to simplify finding the html file
for the latest run of the application; the symlink is called

  `AppName_http_log_newest.html`

For better viewing of XML logs, use Camino or Firefox rather than Safari.

Projects may define `STRIP_GTM_FETCH_LOGGING` to remove logging code, or may just omit the `GTMHTTPFetcherLogging` source files from release builds.

= Questions and Comments =

Additional documentation is available in the header files.

If you have any questions or comments about the library or this documentation, please join the [http://groups.google.com/group/google-toolbox-for-mac discussion group].